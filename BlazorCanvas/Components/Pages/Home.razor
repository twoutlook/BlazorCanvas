@inject IJSRuntime JS

@page "/"

<PageTitle>Home</PageTitle>
<style>
    /* This CSS will only apply within this component */
    .dark-page {
        background-color: #121212;
        color: #e0e0e0;
        min-height: 100vh; /* Ensure it covers the full viewport height */
        padding: 20px;
    }
        /* Override any specific elements if needed */
        .dark-page header,
        .dark-page footer {
            background-color: #1e1e1e;
        }
</style>
<div class="dark-page">
    <div>
        <h3>模擬六人桌發牌</h3>
    </div>
    <div>
        <h4>TODO</h4>
        <ul>
            <li>九人桌要另外 layout</li>
        </ul>
    </div>
<CanvasHelper @ref="CanvasHelper"
              CanvasResized="CanvasResized"
              RenderFrame="RenderFrame"
              MouseDown="MouseDown"
              MouseUp="MouseUp"
              MouseMove="MouseMove">

    <BECanvas Width="600" Height="400" @ref="CanvasReference"></BECanvas>

</CanvasHelper>
   


</div>
<!-- Hidden image elements for preloading -->
<img src="img/deck/Ks.png" style="display:none;" @ref="ImageElements[0]" />
<img src="img/deck/Qs.png" style="display:none;" @ref="ImageElements[1]" />
<img src="img/deck/Js.png" style="display:none;" @ref="ImageElements[2]" />
<img src="img/deck/Ts.png" style="display:none;" @ref="ImageElements[3]" />
<img src="img/deck/9s.png" style="display:none;" @ref="ImageElements[4]" />

@code {
    private bool IsDarkMode = true; // Set based on user preference

    private Size Size = new Size();
    private double FPS;
    private Canvas2DContext Ctx;
    private BECanvasComponent CanvasReference;
    private CanvasHelper CanvasHelper;

    private ElementReference[] ImageElements = new ElementReference[5]; // Store image references
    private double[] cardX = { 100, 160, 220, 280, 340 }; // X positions for cards
    private double cardY = 200; // Y position for all cards
    private int currentCardIndex = -1; // No cards shown initially

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Ctx = await CanvasReference.CreateCanvas2DAsync();
            await CanvasHelper.Initialize();

            await DealCardsAsync();
        }
    }

    private async Task DealCardsAsync()
    {
        await Task.Delay(1000); // Sh
        // Show the first 3 cards (Flop) together
        currentCardIndex = 2;
        await Task.Delay(1000); // Show Flop after 1s

        // Show the 4th card (Turn)
        currentCardIndex = 3;
        await Task.Delay(1000); // Show Turn after 1.5s

        // Show the 5th card (River)
        currentCardIndex = 4;
        await Task.Delay(1000); // Show River after 1.5s
    }

    // private double cardWidth = 144;   // Adjusted card width (slightly wider)
    // private double cardHeight = 198; // Adjusted card height (taller)
    // private double cardWidth = 35;   // Adjusted card width (slightly wider)
    // private double cardHeight = 48.125; // 1.375
    private double cardWidth = 36;   // Adjusted card width (slightly wider)
    private double cardHeight = 49.5; // 1.375

    private double cardSpacing = 38; // Adjusted spacing (closer but still clear)
    private double startX = 100;     // Start position for the first card
    private double startY = 220;     // Slightly lower for a better table look
    public async Task RenderFrame(double fps)
    {
        FPS = fps;
        await this.Ctx.BeginBatchAsync();

        // === 1) Fill background (already dark due to your .dark-page or other styling) ===
        await this.Ctx.SetFillStyleAsync("#000000"); // or #121212
        await this.Ctx.FillRectAsync(0, 0, 600, 400);

        // === 2) Draw the poker table as an oval (using canvas scaling) ===
        // Center of the table in unscaled coordinates
        double centerX = 300;
        double centerY = 200;

        // Draw green felt
        await this.Ctx.SaveAsync();
        await this.Ctx.TranslateAsync(centerX, centerY);
        await this.Ctx.ScaleAsync(2.0, 1.3);
        await this.Ctx.BeginPathAsync();
        await this.Ctx.SetFillStyleAsync("#116611");
        await this.Ctx.ArcAsync(0, 0, 125, 0, 2 * Math.PI, false);
        await this.Ctx.FillAsync();
        await this.Ctx.RestoreAsync();

        // Draw brown border
        await this.Ctx.SaveAsync();
        await this.Ctx.TranslateAsync(centerX, centerY);
        await this.Ctx.ScaleAsync(2.0, 1.3);
        await this.Ctx.BeginPathAsync();
        await this.Ctx.SetStrokeStyleAsync("#774422");
        await this.Ctx.SetLineWidthAsync(8);
        await this.Ctx.ArcAsync(0, 0, 130, 0, 2 * Math.PI, false);
        await this.Ctx.StrokeAsync();
        await this.Ctx.RestoreAsync();

        // Title text
        // await this.Ctx.SetFontAsync("26px Segoe UI");
        // // await this.Ctx.SetFillStyleAsync("#FFFFFF");
        // await this.Ctx.SetFillStyleAsync("#FFFFFF");

        // await this.Ctx.FillTextAsync("OverBankroll", 180, 150);
        // await this.Ctx.SetFontAsync("28px 'Brush Script MT', cursive");
        await this.Ctx.SetFontAsync("28px Segoe UI");

        await this.Ctx.SetFillStyleAsync("#000000"); // Dark green
        await this.Ctx.FillTextAsync("OverBankroll", 180, 150);

        // === 3) Center the 5 community cards on the table ===
        // Example card sizes (tweak as needed)
        double cardWidth = 36;
        double cardHeight = 49.5;
        double cardSpacing = 38;

        // Calculate total width of 5 cards + 4 spaces
        double totalCardWidth = (cardWidth * 5) + (cardSpacing * 4);
        // Start horizontally so that the community cards are centered around centerX
        double startXCommunity = centerX - (totalCardWidth / 2);
        // Adjust vertical placement slightly above or below centerY
        double startYCommunity = centerY - (cardHeight / 2) - 10; // -10 for slight upward shift

        // Draw each community card up to currentCardIndex
        for (int i = 0; i <= currentCardIndex; i++)
        {
            double xPos = startXCommunity + i * cardSpacing;
            await this.Ctx.DrawImageAsync(ImageElements[i], xPos, startYCommunity, cardWidth, cardHeight);
        }

        // === 4) Draw 6 seats around the ellipse (unscaled coordinate system) ===
        // The table's ellipse in unscaled coords is effectively:
        //   Rx = 125 * 2.0 = 250
        //   Ry = 125 * 1.3 = 162.5
        // We'll add an offset so the seats lie outside the border radius
        double tableRadiusX = 125 * 2.0;
        double tableRadiusY = 125 * 1.3;
        double seatOffset = 30; // how far outside the table border to place seats
        double seatRadiusX = tableRadiusX + seatOffset;
        double seatRadiusY = tableRadiusY + seatOffset;

        // Each seat is drawn as a circle in the final coordinate system
        // so we'll just pick a seat circle radius in the final (non-scaled) space
        double seatCircleRadius = 20; // how big each seat circle is

        // 6 seats, evenly spaced: angle increments of 60 degrees (2π/6)
        for (int i = 0; i < 6; i++)
        {
            double angle = i * (2 * Math.PI / 6); // 0, 60°, 120°, ...

            // Parametric ellipse around center
            double seatX = centerX + seatRadiusX * Math.Cos(angle);
            double seatY = centerY + seatRadiusY * Math.Sin(angle);

            await this.Ctx.BeginPathAsync();
            // Draw seat circle with radius seatCircleRadius
            await this.Ctx.ArcAsync(seatX, seatY, seatCircleRadius, 0, 2 * Math.PI, false);
            await this.Ctx.SetFillStyleAsync("#333333");
            await this.Ctx.FillAsync();
            // Optional border
            await this.Ctx.SetStrokeStyleAsync("#FFFFFF");
            await this.Ctx.SetLineWidthAsync(2);
            await this.Ctx.StrokeAsync();
        }

        await this.Ctx.EndBatchAsync();
    }

    public async Task xxxRenderFrame(double fps)
    {
        FPS = fps;
        await this.Ctx.BeginBatchAsync();

        // Dark mode background for the entire page (as set in your scoped CSS)
        await this.Ctx.SetFillStyleAsync("#121212");
        await this.Ctx.FillRectAsync(0, 0, 600, 400);

        // Draw Poker Table Background (Oval Shape)
        await this.Ctx.SaveAsync();
        await this.Ctx.TranslateAsync(300, 200); // center of canvas
        await this.Ctx.ScaleAsync(2.0, 1.3);
        await this.Ctx.BeginPathAsync();
        await this.Ctx.SetFillStyleAsync("#116611"); // Dark green felt
        await this.Ctx.ArcAsync(0, 0, 125, 0, 2 * Math.PI, false);
        await this.Ctx.FillAsync();
        await this.Ctx.RestoreAsync();

        // Draw Poker Table Border
        await this.Ctx.SaveAsync();
        await this.Ctx.TranslateAsync(300, 200);
        await this.Ctx.ScaleAsync(2.0, 1.3);
        await this.Ctx.BeginPathAsync();
        await this.Ctx.SetStrokeStyleAsync("#774422"); // Brown wooden edge
        await this.Ctx.SetLineWidthAsync(8);
        await this.Ctx.ArcAsync(0, 0, 130, 0, 2 * Math.PI, false);
        await this.Ctx.StrokeAsync();
        await this.Ctx.RestoreAsync();

        // Draw Table Title
        await this.Ctx.SetFontAsync("26px Segoe UI");
        await this.Ctx.SetFillStyleAsync("#FFFFFF");
        await this.Ctx.FillTextAsync("Blazor Poker Table", 180, 100);

        // Draw Community Cards (centered)
        double totalCardWidth = (cardWidth * 5) + (cardSpacing * 4);
        double startXCommunity = (600 - totalCardWidth) / 2;
        for (int i = 0; i <= currentCardIndex; i++)
        {
            double cardX = startXCommunity + (i * cardSpacing);
            await this.Ctx.DrawImageAsync(ImageElements[i], cardX, startY, cardWidth, cardHeight);
        }

        // --- New Section: Draw 6 Seats as Circles ---
        // Define the center of the table
        double centerX = 300;
        double centerY = 200;
        // Set the radius of each seat circle (the seat itself)
        double seatRadius = 20;
        // Distance from the table center to where seats should be placed
        double seatCircleRadius = 160;

        // Loop to draw 6 seats evenly spaced around the table
        for (int i = 0; i < 6; i++)
        {
            // Calculate angle (in radians). 2π/6 separation
            double angle = i * (2 * Math.PI / 6);
            double seatX = centerX + seatCircleRadius * Math.Cos(angle);
            double seatY = centerY + seatCircleRadius * Math.Sin(angle);

            await this.Ctx.BeginPathAsync();
            await this.Ctx.ArcAsync(seatX, seatY, seatRadius, 0, 2 * Math.PI, false);
            // Fill the seat with a dark color, adjust as needed
            await this.Ctx.SetFillStyleAsync("#333333");
            await this.Ctx.FillAsync();
            // Optionally, add a border around the seat for visibility
            await this.Ctx.SetStrokeStyleAsync("#FFFFFF");
            await this.Ctx.SetLineWidthAsync(2);
            await this.Ctx.StrokeAsync();
        }

        await this.Ctx.EndBatchAsync();
    }





    public void CanvasResized(Size size)
    {
        Size = size;
    }

    void MouseDown(CanvasMouseArgs args) { }
    void MouseUp(CanvasMouseArgs args) { }
    void MouseMove(CanvasMouseArgs args) { }
}
