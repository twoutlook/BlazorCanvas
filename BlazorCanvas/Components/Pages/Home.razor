@page "/"
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using Blazor.Extensions.Canvas.Model
@inject IJSRuntime JS

<PageTitle>Home</PageTitle>

<style>
    .dark-page {
    background-color: #121212;
    color: #e0e0e0;
    min-height: 100vh;
    padding: 20px;
    }

    .dark-page header,
    .dark-page footer {
    background-color: #1e1e1e;
    }
</style>

<div class="dark-page">
    <div style="display: flex; flex-direction: row;">
        <h3>模擬六人桌發牌</h3>
    </div>
    <div style="display: flex; flex-direction: row;">
        <div style="width: 350px; margin-right: 20px;">
            <p>NOTE</p>
            <ul>
                <li>先確定六人桌基本位置。</li>
                <li>公共牌有按翻牌，轉牌及河牌動態出現。</li>
            </ul>
        </div>

        <div>
            <CanvasHelper @ref="CanvasHelper"
            CanvasResized="CanvasResized"
            RenderFrame="RenderFrame">
                <BECanvas Width="600" Height="400" @ref="CanvasReference"></BECanvas>
            </CanvasHelper>
        </div>
    </div>
</div>

<!-- Preload all 52 card images -->
@foreach (var card in deckList)
{
    <img src="img/deck/@(card).png" style="display:none;" @ref="cardImages[card]" />
}

@code {
    private bool IsDarkMode = true;
    private Size Size = new Size();
    private double FPS;
    private Canvas2DContext Ctx;
    private BECanvasComponent CanvasReference;
    private CanvasHelper CanvasHelper;

    private List<string> deckList = new List<string>
    {
        "As", "Ah", "Ad", "Ac", "Ks", "Kh", "Kd", "Kc", "Qs", "Qh", "Qd", "Qc",
        "Js", "Jh", "Jd", "Jc", "Ts", "Th", "Td", "Tc", "9s", "9h", "9d", "9c",
        "8s", "8h", "8d", "8c", "7s", "7h", "7d", "7c", "6s", "6h", "6d", "6c",
        "5s", "5h", "5d", "5c", "4s", "4h", "4d", "4c", "3s", "3h", "3d", "3c",
        "2s", "2h", "2d", "2c"
    };

    private Dictionary<string, ElementReference> cardImages = new();
    private string[,] playerCards = new string[6, 2];
    private string[] communityCards = new string[5];
    private int currentCardIndex = -1;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Ctx = await CanvasReference.CreateCanvas2DAsync();
            await CanvasHelper.Initialize();
            ShuffleAndDeal();
            await DealCardsAsync();
        }
    }

    private void ShuffleAndDeal()
    {
        List<string> deck = new List<string>(deckList);
        Random rng = new Random();
        deck = deck.OrderBy(_ => rng.Next()).ToList();

        int index = 0;
        for (int i = 0; i < 6; i++)
        {
            playerCards[i, 0] = deck[index++];
            playerCards[i, 1] = deck[index++];
        }

        for (int i = 0; i < 5; i++)
        {
            communityCards[i] = deck[index++];
        }
    }

    private async Task DealCardsAsync()
    {
        await Task.Delay(1000);
        currentCardIndex = 2;
        await Task.Delay(1000);
        currentCardIndex = 3;
        await Task.Delay(1000);
        currentCardIndex = 4;
    }

    public async Task RenderFrame(double fps)
    {
        FPS = fps;
        await Ctx.BeginBatchAsync();
        await Ctx.SetFillStyleAsync("#000000");
        await Ctx.FillRectAsync(0, 0, 600, 400);

        double centerX = 300;
        double centerY = 200;

        await Ctx.SaveAsync();
        await Ctx.TranslateAsync(centerX, centerY);
        await Ctx.ScaleAsync(2.0, 1.3);
        await Ctx.BeginPathAsync();
        await Ctx.SetFillStyleAsync("#116611");
        await Ctx.ArcAsync(0, 0, 125, 0, 2 * Math.PI, false);
        await Ctx.FillAsync();
        await Ctx.RestoreAsync();

        await Ctx.SetFontAsync("28px Segoe UI");
        string tableTitle = "OverBankroll";
        TextMetrics titleMetrics = await Ctx.MeasureTextAsync(tableTitle);
        double titleX = centerX - (titleMetrics.Width / 2);
        double titleY = 160;
        await Ctx.SetFillStyleAsync("#1e4d2b");
        await Ctx.FillTextAsync(tableTitle, titleX, titleY);

        double cardWidth = 36, cardHeight = 49.5, cardSpacing = 38;
        double startXCommunity = centerX - ((cardWidth * 5) + (cardSpacing * 4)) / 2;
        double startYCommunity = centerY - (cardHeight / 2) + 10;
        double startXCommunityAdj = 80;
        for (int i = 0; i <= currentCardIndex; i++)
        {
            if (cardImages.TryGetValue(communityCards[i], out var imageRef))
            {
                double xPos = startXCommunityAdj+startXCommunity + i * cardSpacing;
                await Ctx.DrawImageAsync(imageRef, xPos, startYCommunity, cardWidth, cardHeight);
            }
        }

        double tableRadiusX = 250;
        double tableRadiusY = 162;
        double seatOffset = 30;
        double seatRadiusX = tableRadiusX + seatOffset;
        double seatRadiusY = tableRadiusY + seatOffset;
        double seatCircleRadius = 20;

        for (int i = 0; i < 6; i++)
        {
            double angle = i * (2 * Math.PI / 6);
            double seatX = centerX + seatRadiusX * Math.Cos(angle);
            double seatY = centerY + seatRadiusY * Math.Sin(angle);

            await Ctx.BeginPathAsync();
            await Ctx.ArcAsync(seatX, seatY, seatCircleRadius, 0, 2 * Math.PI, false);
            await Ctx.SetFillStyleAsync("#333333");
            await Ctx.FillAsync();
            await Ctx.SetStrokeStyleAsync("#FFFFFF");
            await Ctx.SetLineWidthAsync(2);
            await Ctx.StrokeAsync();

            for (int j = 0; j < 2; j++)
            {
                if (cardImages.TryGetValue(playerCards[i, j], out var cardRef))
                {
                    double xOffset = seatX - (cardWidth / 2) + (j * cardWidth);
                    double yOffset = seatY - 20;
                    await Ctx.DrawImageAsync(cardRef, xOffset, yOffset, cardWidth, cardHeight);
                }
            }
        }

        await Ctx.EndBatchAsync();
    }

    public void CanvasResized(Size size) => Size = size;
}
