@inject IJSRuntime JS

@page "/"
@using Blazor.Extensions.Canvas.Model

<PageTitle>Home</PageTitle>
<style>
    /* This CSS will only apply within this component */
    .dark-page {
    background-color: #121212;
    color: #e0e0e0;
    min-height: 100vh; /* Ensure it covers the full viewport height */
    padding: 20px;
    }
    /* Override any specific elements if needed */
    .dark-page header,
    .dark-page footer {
    background-color: #1e1e1e;
    }
</style>
<div class="dark-page">
    <div>
        <h3>模擬六人桌發牌</h3>
    </div>
    <div>
        <h4>TODO</h4>
        <ul>
            <li>九人桌要另外 layout</li>
        </ul>
    </div>
    <CanvasHelper @ref="CanvasHelper"
    CanvasResized="CanvasResized"
    RenderFrame="RenderFrame"
    MouseDown="MouseDown"
    MouseUp="MouseUp"
    MouseMove="MouseMove">

        <BECanvas Width="600" Height="400" @ref="CanvasReference"></BECanvas>

    </CanvasHelper>



</div>
<!-- Hidden image elements for preloading -->
<img src="img/deck/Ks.png" style="display:none;" @ref="ImageElements[0]" />
<img src="img/deck/Qs.png" style="display:none;" @ref="ImageElements[1]" />
<img src="img/deck/Js.png" style="display:none;" @ref="ImageElements[2]" />
<img src="img/deck/Ts.png" style="display:none;" @ref="ImageElements[3]" />
<img src="img/deck/9s.png" style="display:none;" @ref="ImageElements[4]" />

@code {
    private bool IsDarkMode = true; // Set based on user preference

    private Size Size = new Size();
    private double FPS;
    private Canvas2DContext Ctx;
    private BECanvasComponent CanvasReference;
    private CanvasHelper CanvasHelper;

    private ElementReference[] ImageElements = new ElementReference[5]; // Store image references
    private double[] cardX = { 100, 160, 220, 280, 340 }; // X positions for cards
    private double cardY = 200; // Y position for all cards
    private int currentCardIndex = -1; // No cards shown initially

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Ctx = await CanvasReference.CreateCanvas2DAsync();
            await CanvasHelper.Initialize();

            await DealCardsAsync();
        }
    }

    private async Task DealCardsAsync()
    {
        await Task.Delay(1000); // Sh
                                // Show the first 3 cards (Flop) together
        currentCardIndex = 2;
        await Task.Delay(1000); // Show Flop after 1s

        // Show the 4th card (Turn)
        currentCardIndex = 3;
        await Task.Delay(1000); // Show Turn after 1.5s

        // Show the 5th card (River)
        currentCardIndex = 4;
        await Task.Delay(1000); // Show River after 1.5s
    }

    // private double cardWidth = 144;   // Adjusted card width (slightly wider)
    // private double cardHeight = 198; // Adjusted card height (taller)
    // private double cardWidth = 35;   // Adjusted card width (slightly wider)
    // private double cardHeight = 48.125; // 1.375
    private double cardWidth = 36;   // Adjusted card width (slightly wider)
    private double cardHeight = 49.5; // 1.375

    private double cardSpacing = 38; // Adjusted spacing (closer but still clear)
    private double startX = 100;     // Start position for the first card
    private double startY = 220;     // Slightly lower for a better table look
    public async Task RenderFrame(double fps)
    {
        FPS = fps;
        await this.Ctx.BeginBatchAsync();

        // 1) Fill the background
        await this.Ctx.SetFillStyleAsync("#000000");
        await this.Ctx.FillRectAsync(0, 0, 600, 400);

        // 2) Draw the poker table (oval)
        double centerX = 300;
        double centerY = 200;

        // Green felt
        await this.Ctx.SaveAsync();
        await this.Ctx.TranslateAsync(centerX, centerY);
        await this.Ctx.ScaleAsync(2.0, 1.3);
        await this.Ctx.BeginPathAsync();
        await this.Ctx.SetFillStyleAsync("#116611");
        await this.Ctx.ArcAsync(0, 0, 125, 0, 2 * Math.PI, false);
        await this.Ctx.FillAsync();
        await this.Ctx.RestoreAsync();

        // Brown border
        await this.Ctx.SaveAsync();
        await this.Ctx.TranslateAsync(centerX, centerY);
        await this.Ctx.ScaleAsync(2.0, 1.3);
        await this.Ctx.BeginPathAsync();
        await this.Ctx.SetStrokeStyleAsync("#774422");
        await this.Ctx.SetLineWidthAsync(8);
        await this.Ctx.ArcAsync(0, 0, 130, 0, 2 * Math.PI, false);
        await this.Ctx.StrokeAsync();
        await this.Ctx.RestoreAsync();

        // 3) Center the table title
        //    - Measure the text width and place it so that it's horizontally centered around centerX.
        await this.Ctx.SetFontAsync("28px Segoe UI");
        string tableTitle = "OverBankroll";
        TextMetrics titleMetrics = await this.Ctx.MeasureTextAsync(tableTitle);
        double titleWidth = titleMetrics.Width;
        double titleX = centerX - (titleWidth / 2); // horizontal centering
        double titleY = 160;                        // adjust as desired (vertical placement)

        // await this.Ctx.SetFillStyleAsync("#FFFFFF");
        await this.Ctx.SetFillStyleAsync("#1e4d2b");

        await this.Ctx.FillTextAsync(tableTitle, titleX, titleY);

        // 4) Draw community cards centered
        double cardWidth = 36;
        double cardHeight = 49.5;
        double cardSpacing = 38;
        int totalCards = 5; // If you always have 5 community cards

        // Calculate total width of the (up to) 5 cards plus spacing
        double totalCardWidth = (cardWidth * totalCards) + (cardSpacing * (totalCards - 1));

        double adjX = 80;
        double startXCommunity = adjX+ centerX - (totalCardWidth / 2);  // horizontally center
        double startYCommunity = centerY - (cardHeight / 2) + 10; // adjust +10 or -10 for vertical offset

        for (int i = 0; i <= currentCardIndex; i++)
        {
            double xPos = startXCommunity + i * cardSpacing;
            await this.Ctx.DrawImageAsync(ImageElements[i], xPos, startYCommunity, cardWidth, cardHeight);
        }

        // 5) Draw the 6 seats around the table border
        double tableRadiusX = 125 * 2.0;
        double tableRadiusY = 125 * 1.3;
        double seatOffset = 30;
        double seatRadiusX = tableRadiusX + seatOffset;
        double seatRadiusY = tableRadiusY + seatOffset;
        double seatCircleRadius = 20; // actual circle radius in final (non-scaled) coords

        for (int i = 0; i < 6; i++)
        {
            double angle = i * (2 * Math.PI / 6); // 0, 60°, 120°, ...
            double seatX = centerX + seatRadiusX * Math.Cos(angle);
            double seatY = centerY + seatRadiusY * Math.Sin(angle);

            await this.Ctx.BeginPathAsync();
            await this.Ctx.ArcAsync(seatX, seatY, seatCircleRadius, 0, 2 * Math.PI, false);
            await this.Ctx.SetFillStyleAsync("#333333");
            await this.Ctx.FillAsync();
            await this.Ctx.SetStrokeStyleAsync("#FFFFFF");
            await this.Ctx.SetLineWidthAsync(2);
            await this.Ctx.StrokeAsync();
        }

        await this.Ctx.EndBatchAsync();
    }

  



    public void CanvasResized(Size size)
    {
        Size = size;
    }

    void MouseDown(CanvasMouseArgs args) { }
    void MouseUp(CanvasMouseArgs args) { }
    void MouseMove(CanvasMouseArgs args) { }
}
